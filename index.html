<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>随笔</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="深度学习安全 | 后端开发 | 技术思考">
<meta property="og:type" content="website">
<meta property="og:title" content="随笔">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="随笔">
<meta property="og:description" content="深度学习安全 | 后端开发 | 技术思考">
<meta property="og:locale">
<meta property="article:author" content="水与酒精与咖啡因">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="随笔" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">随笔</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">学习过程中的一点记录以及生活分享</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-论文阅读笔记/待整理/论文速读-DEAR A Novel Deep Learning-based Approach for Automated Program Repair" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%BE%85%E6%95%B4%E7%90%86/%E8%AE%BA%E6%96%87%E9%80%9F%E8%AF%BB-DEAR%20A%20Novel%20Deep%20Learning-based%20Approach%20for%20Automated%20Program%20Repair/" class="article-date">
  <time class="dt-published" datetime="2025-08-10T14:08:05.509Z" itemprop="datePublished">2025-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%BE%85%E6%95%B4%E7%90%86/%E8%AE%BA%E6%96%87%E9%80%9F%E8%AF%BB-DEAR%20A%20Novel%20Deep%20Learning-based%20Approach%20for%20Automated%20Program%20Repair/">论文速读-DEAR A Novel Deep Learning-based Approach for Automated Program Repair</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="论文基本情况："><a href="#论文基本情况：" class="headerlink" title="论文基本情况："></a>论文基本情况：</h1><blockquote>
<h2 id="论文名：DEAR-A-Novel-Deep-Learning-based-Approach-for-Automated-Program-Repair"><a href="#论文名：DEAR-A-Novel-Deep-Learning-based-Approach-for-Automated-Program-Repair" class="headerlink" title="论文名：DEAR: A Novel Deep Learning-based Approach for Automated Program Repair"></a><strong>论文名</strong>：DEAR: A Novel Deep Learning-based Approach for Automated Program Repair</h2></blockquote>
<blockquote>
<h2 id="作者：Yi-Li-New-Jersey-Inst-of-Technology-Shaohua-Wang-University-of-Waterlor-Tien-N-Nguyen-University-of-Texas-at-Dallas"><a href="#作者：Yi-Li-New-Jersey-Inst-of-Technology-Shaohua-Wang-University-of-Waterlor-Tien-N-Nguyen-University-of-Texas-at-Dallas" class="headerlink" title="作者：Yi Li(New Jersey Inst. of Technology), Shaohua Wang(University of Waterlor), Tien N. Nguyen(University of Texas at Dallas)"></a><strong>作者</strong>：Yi Li(New Jersey Inst. of Technology), Shaohua Wang(University of Waterlor), Tien N. Nguyen(University of Texas at Dallas)</h2></blockquote>
<blockquote>
<h2 id="来源：2022-ICSE"><a href="#来源：2022-ICSE" class="headerlink" title="来源：2022 ICSE"></a><strong>来源</strong>：2022 ICSE</h2></blockquote>
<blockquote>
<h2 id="论文主题：漏洞修复，-Software-maintenance-tools"><a href="#论文主题：漏洞修复，-Software-maintenance-tools" class="headerlink" title="论文主题：漏洞修复， Software maintenance tools"></a><strong>论文主题</strong>：漏洞修复， Software maintenance tools</h2></blockquote>
<h1 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a>论文阅读</h1><p>这一篇也是在ICSE上发的，跟之前的CURE一样。所以说，这方面的研究还是主要集中在软工领域？毕竟安全四大也看了一些，但漏洞修复相关的内容看到的还是比较少，之后可以多注意一下软工的会。<br>题目上看不出有什么新意，属于是比较简单、朴素的题目了。<br>开门见山，一句简单的背景后，直接说明了本文方法的核心，能够修复一行或多行的漏洞，这个跟之前看到的一些都不一样。DEAR中包含了一个漏洞定位的功能，这也支持了多行的修复。结合传统的基于谱频的定位方法与深度学习模型来进行定位，具体的定位方法目前没有看太懂。而修复方面，设计了两层基于树的LSTM模型，这个模型结构之后可以参考一下，使用“分而治之”的策略来学习正确的代码转换，这个“分而治之”之后应该需要多注意一下。再之后就是修复效果的说明，牛就完事了。</p>
<p>Introduction部分开头写的比较直接，可能还是方法比较硬。介绍了现有的方法，基于搜索的，软件挖掘和修复模式学习，机器学习结合软件挖掘，还有一些基于DL的方法。这些东西写的非常简洁，两段所有的事情就说完了。再之后对基于DL的方法的缺陷进行分析。对一般缺陷存在限制，这些缺陷一般需要对多行进行修改。但这个实际上是有局限的（虽然上一篇论文也是针对一行代码做的），这种模式限制了这一类方法的进步。<br>本文的方法支持一次性修复属于一个或多个错误代码块的一个或多个错误语句的依赖更改的一般错误。</p>
<ol>
<li>多块多行漏洞定位技术。SBFL来识别可疑语句的列表，再把这些内容输入到微调后的BERT中，得到需要一起修复的错误块。还对块中的错误语句作为种子，通过RNN进行错误分类，通过数据流分析进行调整，最终得到错误块。方法很复杂，确实很牛逼。</li>
<li>得到漏洞分布后，用分治策略来学习AST中的每个字数的转换，来学习细粒度的变化和修复的映射。</li>
<li>两层的模型结构，结合注意力层和循环训练，对于定位出每个有漏洞的子树，编码为向量，第一层学习修复上下文，下一层以上下文为权重来修复有缺陷的子树。这个实际上跟CURE有点类似，CURE的encoder有两个，一个学bug，一个学上下文。</li>
<li>最后，对子树进行修复，修复后的子树代表了正确的代码。<br>但最后贡献部分写的不是很舒服，格式很乱。</li>
</ol>
<p>Motivation部分作为第二章，通过一个例子进行说明。但问题在于斜体字用的很乱，看的不是很舒服。<br>下面对于其他方法的分析实际上有些不是很认同，之前的方法只假定某一行出问题，其他行均正确，按文中的说法仍然无法通过测试样例。但之前的研究同样有一个假设或者说设定，修复并不是指不存在任何漏洞，而是较修复前的代码能通过更多的测试样例。而没有一种方法能保证修复后的程序不会有任何问题。话虽这么说，一次能将所有已知的漏洞都修复完成肯定更好。<br>而且，仔细想一想，图一的例子，第5行和第10行实际上属于两个漏洞，逻辑上还是有点不太顺。<br>这个思路之前确实也想过，但没这么细致。将代码转化为语法树，对语法树进行修改和调整，修复结束后再转化为代码，这样实际上也实现了多行的修复—-因为语法树的修改结果可能反映到多行上。<br>但对于分的点，不是很清楚，<strong>为什么把子树的转化和修复上下文分成两部分</strong>，可能后面会有答案。这是一个点，另一个点在于 <strong>dependent fixing changes</strong>和<strong>dependently changed together</strong> 这些都是什么意思</p>
<p>在下面2.2 对上面的几点做了更详细的说明。定位上，先用SBFL给出所有可能的缺陷位置，并包含怀疑度。之后，首先用深度学习模型来检测其他相邻的代码是否需要跟某一行一起修复。因为SBFL只会返回可疑的候选位置，但不一定会一起修复。其次，设计了一个扩展算法，将可疑的语句所再的块组合在一起。需要看下代码和后面的内容，目前的理解是SBFL定位，先用模型决定定位出的漏洞是单行还是多行，最后，将所有的块组合到一起，确定所有需要修复的部分。<br>一块对应了一个子树，对应一个bug，分别使用模型进行处理。使用了一个变更检测模型来对应修复前后的变化。这个在其他的方案中应该是没有的，因为DEAR应用于多行多漏洞，可能修复前是3行，修复后变成了5行，而且还不止一个漏洞，因此可能会出现修复a的漏洞，放到了b的位置。但逐个修复不能处理吗？分而治之的思路实际上也是这么个流程<br>实际上貌似也是这么做的？<del>两层的模型一次只修复一个子树</del>第一层，将有bug的子树，用一个伪节点占位，新的AST作为修复的上下文。这个伪节点是通过嵌入技术计算出的。第二层负责生成任务，学习bug到补丁的转变（可能是n行到m行）。第一层得出的修复上下文向量作为第二层的权重，对每个有bug的子树重复相同的过程。一次对所有的语句都执行。</p>
<p>最核心部分 方法概述<br>训练流程：输入是修复前代码，输出两个模型，一个上下文模型，另一个树转换模型。前者学习权重，代表上下文的影响，对树变换的结果进行调整；后者学习代码转化，负责修复任务。	<br>上下文学习：先构建训练数据，用CPatMiner负责对子树的处理。错误语句的AST子树被映射到各自的修复子树，并进行学习；树转换学习：同样是用CPatMiner导出子树映射，错误子树与对应的修复子树在第二个模型进行训练。还是没搞明白这两个模型的区别在哪里，感觉第一个模型就已经实现了修复代码的生成？第二个模型的作用不是很明显，感觉就是跑了两遍，另一个角度，思考一下，是不是跟CURE是一种？训练的数据还是有一点不同？<br>修复流程：先错误定位，再将连续的错误代码组合起来，对有缺陷的子树，输入上下文模型CTL中，产生权重，在输入树转换模型TTL，产生修复子树，最后用语法规则和程序分析产生修复代码，验证方法与DLFix相同</p>
<p>训练过程</p>
<ol>
<li>构建bug和修复代码：<ol>
<li>如果子树对应一条语句，则称为statement subtree。根据CPatMiner的结果，对应的规则如下：<ol>
<li>bug子树（S-subtree）分为两类：更新或删除的子树；</li>
<li>如果是删除子树，则与空树对应，也就是没有对应的修复代码；</li>
<li>如果是更新（子树更新或子节点插入删除更改），将bug子树和修复子树成对；</li>
<li>如果插入了一个子树，且父节点是另一个子树，将被插入的子树与父节点匹配，如果父节点不是S-subtree，则与空子树对应</li>
</ol>
</li>
<li>不清楚的是，每个子树的构建规则是什么？也就是哪些语句转化成的子树</li>
</ol>
</li>
<li>上下文构建：有一组对应的bugAST$I_1$和修复AST$O_1$ <ol>
<li>第一步：对每个节点，转化成词向量（GloVe）–语句节点看一个句子，每个标记作为单词，得到向量化的结果$I_2$和$O_2$</li>
<li>对bugAST和修复AST中对应的子树 $T_b$和$T_f$逐一处理。首先，用TreeCaps对$T_b$和$T_f$分别汇总，记录树结构到$V_s$和$V_s^{‘}$。其次，对于其他的所有bug子树 $T_b^{‘}$和对应的修复字数 $T_f^{‘}$，用$T_f^{‘}$替换$T_b^{‘}$来构建上下文$I_3$，为了保持正确的上下文信息，在$O_3$中保留$T_f^{‘}$。这一部分有点看不懂了又…问题在于$T_b$和 $T_b^{‘}$是什么关系？为什么要互相替代</li>
<li>$I_3$作为有缺陷的修复前上下文，并用于CTL编码器的输入层的学习，$O_3$作为修复后上下文，用于解码器的输出层。</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%BE%85%E6%95%B4%E7%90%86/%E8%AE%BA%E6%96%87%E9%80%9F%E8%AF%BB-DEAR%20A%20Novel%20Deep%20Learning-based%20Approach%20for%20Automated%20Program%20Repair/" data-id="cme5ri1i30001qodjghk4hibo" data-title="论文速读-DEAR A Novel Deep Learning-based Approach for Automated Program Repair" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-论文阅读笔记/待整理/CURE Code-Aware Neural Machine Translation for Automatic Program Repair" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%BE%85%E6%95%B4%E7%90%86/CURE%20Code-Aware%20Neural%20Machine%20Translation%20for%20Automatic%20Program%20Repair/" class="article-date">
  <time class="dt-published" datetime="2025-08-10T14:07:31.227Z" itemprop="datePublished">2025-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%BE%85%E6%95%B4%E7%90%86/CURE%20Code-Aware%20Neural%20Machine%20Translation%20for%20Automatic%20Program%20Repair/">CURE Code-Aware Neural Machine Translation for Automatic Program Repair</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="论文基本情况："><a href="#论文基本情况：" class="headerlink" title="论文基本情况："></a>论文基本情况：</h1><blockquote>
<h2 id="论文名：-CURE-Code-Aware-Neural-Machine-Translation-for-Automatic-Program-Repair"><a href="#论文名：-CURE-Code-Aware-Neural-Machine-Translation-for-Automatic-Program-Repair" class="headerlink" title="论文名： CURE: Code-Aware Neural Machine Translation for Automatic Program Repair"></a><strong>论文名</strong>： CURE: Code-Aware Neural Machine Translation for Automatic Program Repair</h2></blockquote>
<blockquote>
<h2 id="作者：Nan-Jiang-Purdue-University-ThiBaud-Lutellier-University-of-Waterlor-Lin-Tan-Purdue-University"><a href="#作者：Nan-Jiang-Purdue-University-ThiBaud-Lutellier-University-of-Waterlor-Lin-Tan-Purdue-University" class="headerlink" title="作者：Nan Jiang(Purdue University), ThiBaud Lutellier(University of Waterlor), Lin Tan(Purdue University)"></a><strong>作者</strong>：Nan Jiang(Purdue University), ThiBaud Lutellier(University of Waterlor), Lin Tan(Purdue University)</h2></blockquote>
<blockquote>
<h2 id="作者：Nan-Jiang-Purdue-University-ThiBaud-Lutellier-University-of-Waterlor-Lin-Tan-Purdue-University-1"><a href="#作者：Nan-Jiang-Purdue-University-ThiBaud-Lutellier-University-of-Waterlor-Lin-Tan-Purdue-University-1" class="headerlink" title="作者：Nan Jiang(Purdue University), ThiBaud Lutellier(University of Waterlor), Lin Tan(Purdue University)"></a><strong>作者</strong>：Nan Jiang(Purdue University), ThiBaud Lutellier(University of Waterlor), Lin Tan(Purdue University)</h2></blockquote>
<blockquote>
<h2 id="来源：2021-ICSE"><a href="#来源：2021-ICSE" class="headerlink" title="来源：2021 ICSE"></a><strong>来源</strong>：2021 ICSE</h2></blockquote>
<blockquote>
<h2 id="论文主题：程序修复，程序语言处理"><a href="#论文主题：程序修复，程序语言处理" class="headerlink" title="论文主题：程序修复，程序语言处理"></a><strong>论文主题</strong>：程序修复，程序语言处理</h2></blockquote>
<h1 id="一句话论文："><a href="#一句话论文：" class="headerlink" title="一句话论文："></a>一句话论文：</h1><blockquote>
<p>本文将程序语言预训练的GPT模型与翻译模型结合起来，共同作为自动程序修复(ARP, Auromatic Program Repair)模型工作，并设计了一种Code-aware定向搜索策略，通过关注可编译且与原长度类似的补丁，缩小搜索空间，提高生成补丁工的可编译率，使质量高的补丁排序更靠前，提高了修复成功率。</p>
</blockquote>
<h1 id="重点与思考："><a href="#重点与思考：" class="headerlink" title="重点与思考："></a>重点与思考：</h1><blockquote>
<p>这篇文章作为2021年的SOTA，将其他领域内的一些技术迁移到自动修复这一问题上，在两个常用数据集上取得了比较好的效果，并为自动化漏洞修复这一方向中存在的一些问题，提供了部分解决思路。</p>
</blockquote>
<blockquote>
<h2 id="1-程序语言的数据以及词表问题"><a href="#1-程序语言的数据以及词表问题" class="headerlink" title="1. 程序语言的数据以及词表问题"></a><strong>1. 程序语言的数据以及词表问题</strong></h2></blockquote>
<blockquote>
<blockquote>
<p>由于标识符命名过于自由，导致可能存在的命名空间无限大，使词汇表的大小过大。对于模型训练来说，过大的词表将导致训练效率的下降，时间成本过大；另一方面，如果单纯地将一个标识符标注为一个向量，100个变量标注100个，忽视了变量命名间的关系和可能存在的规律，可能还会影响模型的性能。目前，存在一种方法是提取出所有的变量名，维护一张变量表，记录对应的位置，在训练时将其全部标注为一个向量，在生成补丁时，根据位置，查找之前维护的表，将原变量名导入到补丁中，但该方法相当于直接舍弃掉变量名的含义，这一点是跟人的直观印象是不符的，且生成后再赋予变量名，这一行为的正确率应该也不会特别高。<br>本文使用的策略是采用子词划分策略，类似于Bert等模型中的分词方法。将一个组合词分割成不同的部分，比如max_here被分成’max’，’_’，’here’三部分，这样的话，词表大小被大大缩减，保留了变量名的部分语义信息，并且，是后续对生成补丁进行筛选的基础<br>此外，在之前的其他研究中，修复的过程中都只关注出现问题的代码行，而忽视了整体代码段的内容，本文中规避了这个问题，充分利用了出错行之前的代码，提高修复成功的概率。<br>虽然，词表以及变量名表示的问题，虽然感觉非常重要，但是，并没有看到相关的研究，这应该是之后的一个研究的方向</p>
</blockquote>
</blockquote>
<blockquote>
<h2 id="2-模型训练与推理流程"><a href="#2-模型训练与推理流程" class="headerlink" title="2. 模型训练与推理流程"></a><strong>2. 模型训练与推理流程</strong></h2></blockquote>
<blockquote>
<blockquote>
<p>文中提出的APR模型包含两部分，预训练的GPT模型和神经网络翻译模型(Context-aware neural machine translation (CoNuT))，一起作为APR模型进行补丁生成。因此，模型训练阶段也分为两部分，GPT预训练和ARP微调。<br>在GPT训练阶段，使用的数据是从github上提取的所有Java项目，需要注意的是，由于微调阶段的数据来源也是开源项目，因此，需要避免使用出现Bug的代码，即该阶段使用的训练数据需要使用2006年前的提交信息，也不需要关注其中是否包含漏洞等信息，因为，预训练部分主要目的是使模型能够学到人类编写的代码的特点。任务是下一单词预测。<br>在微调阶段，使用的数据是CoCoNuT所使用的数据，涵盖了训练阶段使用的项目。微调过程中，将GPT和CoNuT结合起来，一起微调。损失包含了两部分，$L_{NMT}$和$\lambda L_{GPT}$，前者是在已知Bug行和Bug行前的内容情况下，调整两部分模型参数，最大化预测下一个单词的平均概率(应该类似于自然语言生成任务)，后者是生成的补丁时正确补丁的概率。<br>在推理阶段，首先会把整体代码段输入到GPT模型中，提取代码特征，生成上下文代码表示和Bug行代码表示，其次，会把Bug前的代码，以及目标生成的字符的前一个字符输入模型中，提取相应特征，一种四部分代码表示，共同作为代码生成的输入数据，推断下一个字符，随后，递归生成整个补丁。</p>
</blockquote>
</blockquote>
<blockquote>
<h2 id="3-筛选和搜索策略"><a href="#3-筛选和搜索策略" class="headerlink" title="3. 筛选和搜索策略"></a><strong>3. 筛选和搜索策略</strong></h2><blockquote>
<p>生成补丁后，如何在生成的众多代码中选择正确的补丁也是一个非常重要的问题，本文使用的是定向搜索算法，并对其做了一些改进。主要采取了两种策略，有效性验证和长度控制。后者是基于一个统计学概念，经统计发现，正确补丁与原错误代码间长度差距，大多数均不超过5，因此，在使用模型生成补丁时，更倾向于选择与原长度类似的代码，且惩罚过短或过长的补丁。该策略还有一个好处是，搜索的空间更深，更容易生成补丁。<br>前者则是对定向搜索算法的改进，Vanilla beam search算法没有对搜索树进行处理，仅考虑概率问题，可能会选择无法编译的代码。而改进后的Code-aware beam search 会首先根据生成的子词，判断某一条路径走下去，是否能形成正确的标识符，剪枝掉会导致错误的路径，减少了搜索空间，且可编译性大大增加。</p>
</blockquote>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%BE%85%E6%95%B4%E7%90%86/CURE%20Code-Aware%20Neural%20Machine%20Translation%20for%20Automatic%20Program%20Repair/" data-id="cme5ri1hu0000qodj7vcy3qcv" data-title="CURE Code-Aware Neural Machine Translation for Automatic Program Repair" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-论文阅读笔记/待整理/Defending Pre-trained Language Models from Adversarial Word Substitution Without Performance Sacrifice" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%BE%85%E6%95%B4%E7%90%86/Defending%20Pre-trained%20Language%20Models%20from%20Adversarial%20Word%20Substitution%20Without%20Performance%20Sacrifice/" class="article-date">
  <time class="dt-published" datetime="2025-08-10T14:06:57.167Z" itemprop="datePublished">2025-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%BE%85%E6%95%B4%E7%90%86/Defending%20Pre-trained%20Language%20Models%20from%20Adversarial%20Word%20Substitution%20Without%20Performance%20Sacrifice/">第一篇-测试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="论文名：Defending-Pre-trained-Language-Models-from-Adversarial-Word-Substitution-Without-Performance-Sacrifice–在不牺牲性能的情况下为训练前的语言模型对抗性词替换进行防御"><a href="#论文名：Defending-Pre-trained-Language-Models-from-Adversarial-Word-Substitution-Without-Performance-Sacrifice–在不牺牲性能的情况下为训练前的语言模型对抗性词替换进行防御" class="headerlink" title="论文名：Defending Pre-trained Language Models from Adversarial Word Substitution Without Performance Sacrifice–在不牺牲性能的情况下为训练前的语言模型对抗性词替换进行防御"></a>论文名：Defending Pre-trained Language Models from Adversarial Word Substitution Without Performance Sacrifice–在不牺牲性能的情况下为训练前的语言模型对抗性词替换进行防御</h1><h1 id="作者：Rongzhou-Bao-Jiayi-Wang-Hai-Zhao"><a href="#作者：Rongzhou-Bao-Jiayi-Wang-Hai-Zhao" class="headerlink" title="作者：Rongzhou Bao; Jiayi Wang; Hai Zhao"></a>作者：Rongzhou Bao; Jiayi Wang; Hai Zhao</h1><h1 id="期刊：ACL2021"><a href="#期刊：ACL2021" class="headerlink" title="期刊：ACL2021"></a>期刊：ACL2021</h1><h1 id="论文主题："><a href="#论文主题：" class="headerlink" title="论文主题："></a>论文主题：</h1><h1 id="阅读状态："><a href="#阅读状态：" class="headerlink" title="阅读状态："></a>阅读状态：</h1><h1 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h1><ol>
<li>本文提出了一种针对同义词替换攻击的防御方法，防御思路主要是对于输入的句子，选出其中频率低于某一阈值的低频词和随机挑选出部分词，这两部分共同组成候选词池，之后，根据单词相似性得到候选词池（本文中相似性是通过词向量的余弦值表示？），从中选出概率较高的，最后再从中随机选出一个，进行替换。</li>
<li>模型分类流程：首先，异常检测器预测输入样本是否敌对。如果输入样本被确定为非对抗性的，则直接使用文本分类器(标签A)的输出作为其最终预测。如果输入样本被确定为对抗样本，则对原始输入样本应用频率感知随机化过程。然后，将随机化的样本再次发送到PrLM，文本分类器的第二个输出作为结果被用作最后的预测。</li>
<li>比赛里要用的应该是异常检测部分和频率感知随机化过程。</li>
</ol>
<h1 id="相关论文："><a href="#相关论文：" class="headerlink" title="相关论文："></a>相关论文：</h1><ol>
<li>与Frequency-Guided Word Substitutions for Detecting Textual Adversarial Examples类似，方法相同，都是基于词频检测的防御，需要对比</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%BE%85%E6%95%B4%E7%90%86/Defending%20Pre-trained%20Language%20Models%20from%20Adversarial%20Word%20Substitution%20Without%20Performance%20Sacrifice/" data-id="cme5ri1i60004qodjf6ut9thp" data-title="第一篇-测试" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-论文阅读笔记/待整理/Virtual Adversarial Training A Regularization Method for Supervised and Semi-Supervised Learning" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%BE%85%E6%95%B4%E7%90%86/Virtual%20Adversarial%20Training%20A%20Regularization%20Method%20for%20Supervised%20and%20Semi-Supervised%20Learning/" class="article-date">
  <time class="dt-published" datetime="2025-08-10T14:06:29.453Z" itemprop="datePublished">2025-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%BE%85%E6%95%B4%E7%90%86/Virtual%20Adversarial%20Training%20A%20Regularization%20Method%20for%20Supervised%20and%20Semi-Supervised%20Learning/">第一篇-测试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="论文名：Virtual-Adversarial-Training-A-regularization-Method-for-Supervised-and-Semi-Supervised-Learning"><a href="#论文名：Virtual-Adversarial-Training-A-regularization-Method-for-Supervised-and-Semi-Supervised-Learning" class="headerlink" title="论文名：Virtual Adversarial Training: A regularization Method for Supervised and Semi-Supervised Learning"></a>论文名：Virtual Adversarial Training: A regularization Method for Supervised and Semi-Supervised Learning</h1><h1 id="作者：Takeru-Miyato，-Shin-Ichi-Maeda，-Masanori-Koyama-and-Shin-Ishii"><a href="#作者：Takeru-Miyato，-Shin-Ichi-Maeda，-Masanori-Koyama-and-Shin-Ishii" class="headerlink" title="作者：Takeru Miyato， Shin-Ichi Maeda， Masanori Koyama, and Shin Ishii"></a>作者：Takeru Miyato， Shin-Ichi Maeda， Masanori Koyama, and Shin Ishii</h1><h1 id="期刊：IEEE-TPAMI-2019"><a href="#期刊：IEEE-TPAMI-2019" class="headerlink" title="期刊：IEEE-TPAMI-2019"></a>期刊：IEEE-TPAMI-2019</h1><h1 id="论文主题：虚拟对抗攻击；正则化"><a href="#论文主题：虚拟对抗攻击；正则化" class="headerlink" title="论文主题：虚拟对抗攻击；正则化"></a>论文主题：虚拟对抗攻击；正则化</h1><h1 id="阅读状态：粗读"><a href="#阅读状态：粗读" class="headerlink" title="阅读状态：粗读"></a>阅读状态：粗读</h1><h1 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h1><ol>
<li>在第一页右下那一段(In fact, smoothing the output…)中，提到了两点。<ol>
<li>标签传播算法(label propagation)认为输入类似的内容应该具有相同的标签。</li>
<li>在深度学习中，可以通过在样本中加入随机扰动，生成人工输入点，并且鼓励模型分配给这些样本相同的标签。这一操作对模型鲁棒性有提升。这种方法是正则化方法，例如L1，L2等</li>
<li>下面说明了这种等方向扰动的问题，使模型非常容易受到特定方向的攻击，也就是攻击方向，这个方向上模型最为敏感。即使是非常微小的扰动，也会分类错误。所以说，可以提高鲁棒性，但无法有效对抗攻击</li>
<li>第3点的内容启发了对抗训练的产生。提高了泛化性和对对抗攻击的鲁棒性。<blockquote>
<p>Doodfellow提出的方法是什么逻辑？一个样本两个标签</p>
</blockquote>
</li>
</ol>
</li>
<li>提出一个概念：虚拟对抗方向(VAD)–能够最大程度上改变输出分布的扰动方向<ol>
<li>goodfollew等人提出对抗方向，最大程度上改变分类置信度，或者说是最大程度上使模型分类结果偏离正确标签</li>
<li>两者不同：VAD可以在无标签数据上–最大程度上使 目前推断出的输出分布 偏离现状–也就是说即使缺乏标签数据，VAD也可以定义，就像有一个虚拟的标签一样–因此叫虚拟对抗方向</li>
<li>同向性(等方向性)和各向异性</li>
<li>对VAD的个人理解：<ol>
<li><pre><code>VAD是使目前的分类发生最大偏移，并不在乎原来指向那边，也不在乎偏移去哪里；而AD是使模型分类结果原理正确标签。
</code></pre>
</li>
<li>虚拟的理解：将目前的分类结果作为标签，并不存在一个真实的标签</li>
</ol>
</li>
</ol>
</li>
<li>另一个概念：局部分布光滑(LDS)–模型对VAD的发散分布鲁棒性</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%BE%85%E6%95%B4%E7%90%86/Virtual%20Adversarial%20Training%20A%20Regularization%20Method%20for%20Supervised%20and%20Semi-Supervised%20Learning/" data-id="cme5ri1i50003qodj1bfdh5na" data-title="第一篇-测试" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-GitHub Pages + Hexo 搭建个人博客" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/03/GitHub%20Pages%20+%20Hexo%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" class="article-date">
  <time class="dt-published" datetime="2025-08-03T13:35:16.898Z" itemprop="datePublished">2025-08-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/03/GitHub%20Pages%20+%20Hexo%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">GitHub Pages + Hexo 搭建个人博客</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、前期调研"><a href="#一、前期调研" class="headerlink" title="一、前期调研"></a>一、前期调研</h2><p><strong>Hexo</strong>（Node.js驱动）：  </p>
<ul>
<li>优势：插件生态丰富，Markdown 写作友好，主题更换一键完成，且无需服务器配置</li>
<li>场景：<strong>技术博客首选</strong>，尤其适合需要深度定制的开发者</li>
</ul>
<p><strong>Hugo</strong>（Go语言构建）：  </p>
<ul>
<li>优势：编译速度快，无需环境依赖  </li>
<li>场景：<strong>内容频繁更新的资讯站</strong>，如新闻&#x2F;产品日志</li>
</ul>
<p><strong>Jekyll</strong>（Ruby生态）：  </p>
<ul>
<li>优势：GitHub Pages 原生支持，历史教程资源最全  </li>
<li>场景：<strong>纯写作型博客</strong>，无需技术配置的用户</li>
</ul>
<p><strong>VuePress</strong>（Vue技术栈）：  </p>
<ul>
<li>优势：强交互组件支持，默认支持 Service Worker 缓存  </li>
<li>场景：<strong>开发文档&#x2F;教程站点</strong>，需嵌入动态演示的场景</li>
</ul>
<h2 id="二、环境配置"><a href="#二、环境配置" class="headerlink" title="二、环境配置"></a>二、环境配置</h2><ol>
<li>安装 Node.js<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Windows/Mac：官网下载 LTS 版本</span><br><span class="line">https://nodejs.org/zh-cn/download</span><br><span class="line"># 验证安装：node -v 和 npm -v</span><br></pre></td></tr></table></figure></li>
<li>安装 Git 并配置—-这一步其他博客比较多，可以搜一下，按步骤操作<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  # Windows：官网下载安装</span><br><span class="line">  https://nodejs.org/zh-cn/download</span><br><span class="line">  # 配置全局用户信息</span><br><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的邮箱&quot;</span><br><span class="line">  # 生成密钥</span><br><span class="line">   ssh-keygen -t rsa -C &quot;XXX@XX.XX&quot; # 注册邮箱</span><br><span class="line">  # 获取公钥（id_rsa.pub）--一般在用户目录下的.ssh中</span><br><span class="line">cd ~/.ssh</span><br><span class="line">cat id_rsa.pub</span><br><span class="line">  # 在github中settings中配置</span><br><span class="line"># 粘贴公钥</span><br><span class="line">  # 验证</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li>
<li>安装 Hexo 脚手架 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo --version  # 验证安装</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="三、项目初始化"><a href="#三、项目初始化" class="headerlink" title="三、项目初始化"></a>三、项目初始化</h2><ol>
<li>创建博客项目 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init my-blog  # 初始化项目</span><br><span class="line">cd my-blog</span><br><span class="line">npm install        # 安装依赖</span><br></pre></td></tr></table></figure>
 目录结构说明：<br> - source&#x2F;_posts&#x2F;：存放 Markdown 文章<br> - themes&#x2F;：主题文件夹<br> - public&#x2F;：执行 hexo g 后生成的静态文件</li>
<li>本地预览–这里本身只是为了本地预览，部署之后就不需要了 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server  # 访问 http://localhost:4000</span><br></pre></td></tr></table></figure></li>
<li>安装主题 hexo主题网站 <a target="_blank" rel="noopener" href="https://hexo.io/themes/">https://hexo.io/themes/</a> （以 Butterfly 为例）<ol>
<li>安装主题 <code>git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</code></li>
<li>然后修改根目录下配置文件_config.yml：<code>theme: butterfly  # 启用主题</code></li>
<li>安装渲染插件<code>npm install hexo-renderer-pug hexo-renderer-stylus --save #避免页面空白问题</code></li>
</ol>
</li>
</ol>
<h2 id="四、部署到-GitHub-Pages"><a href="#四、部署到-GitHub-Pages" class="headerlink" title="四、部署到 GitHub Pages"></a>四、部署到 GitHub Pages</h2><ol>
<li>创建 GitHub 仓库<ol>
<li>仓库名必须为 <strong>&lt;用户名&gt;.github.io</strong>，且设为公有</li>
</ol>
</li>
<li>安装部署插件 <code>npm install hexo-deployer-git --save</code></li>
<li>修改根目录下配置文件_config.yml： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yourname/yourname.github.io.git  # SSH 地址</span><br><span class="line">  branch: main  # 分支</span><br></pre></td></tr></table></figure></li>
<li>一键部署 <code>hexo clean &amp;&amp; hexo g -d</code> 或 <code>hexo clean; hexo g; hexo d</code>，即可访问访问：<code>https://yourname.github.io</code></li>
<li>如果部署失败的话，可以尝试将配置中的仓库地址改为http地址<code>repo: https://github.com/用户名/仓库名.git</code></li>
</ol>
<h2 id="五、内容发布以及更新"><a href="#五、内容发布以及更新" class="headerlink" title="五、内容发布以及更新"></a>五、内容发布以及更新</h2><ol>
<li>可以通过<code>hexo new &quot;文章标题&quot; </code> 的形式创建新内容，md文件生成在<code>\source\_posts\</code>中</li>
<li>重复执行 <code>hexo g -d </code>即可同步到线上</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/03/GitHub%20Pages%20+%20Hexo%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" data-id="cme5ri1i40002qodjdqp23gn8" data-title="GitHub Pages + Hexo 搭建个人博客" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/03/hello-world/" class="article-date">
  <time class="dt-published" datetime="2025-08-03T13:06:46.522Z" itemprop="datePublished">2025-08-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/03/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/03/hello-world/" data-id="cme5rasb30000vsdj158kbn0r" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">August 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/08/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%BE%85%E6%95%B4%E7%90%86/%E8%AE%BA%E6%96%87%E9%80%9F%E8%AF%BB-DEAR%20A%20Novel%20Deep%20Learning-based%20Approach%20for%20Automated%20Program%20Repair/">论文速读-DEAR A Novel Deep Learning-based Approach for Automated Program Repair</a>
          </li>
        
          <li>
            <a href="/2025/08/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%BE%85%E6%95%B4%E7%90%86/CURE%20Code-Aware%20Neural%20Machine%20Translation%20for%20Automatic%20Program%20Repair/">CURE Code-Aware Neural Machine Translation for Automatic Program Repair</a>
          </li>
        
          <li>
            <a href="/2025/08/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%BE%85%E6%95%B4%E7%90%86/Defending%20Pre-trained%20Language%20Models%20from%20Adversarial%20Word%20Substitution%20Without%20Performance%20Sacrifice/">第一篇-测试</a>
          </li>
        
          <li>
            <a href="/2025/08/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%BE%85%E6%95%B4%E7%90%86/Virtual%20Adversarial%20Training%20A%20Regularization%20Method%20for%20Supervised%20and%20Semi-Supervised%20Learning/">第一篇-测试</a>
          </li>
        
          <li>
            <a href="/2025/08/03/GitHub%20Pages%20+%20Hexo%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">GitHub Pages + Hexo 搭建个人博客</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 水与酒精与咖啡因<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>